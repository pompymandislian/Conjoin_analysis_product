# -*- coding: utf-8 -*-
"""Machine Learning Conjoint.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fV0G_h0KUKTlW39oY4rohfVPx4UZvHSn
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

import sklearn
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import OneHotEncoder, StandardScaler, MinMaxScaler, Normalizer
from sklearn.model_selection import train_test_split, GridSearchCV
import warnings
from sklearn.linear_model import LinearRegression
warnings.filterwarnings('ignore')

# read data
df = pd.read_csv('matching_data_df.csv')
df_other = pd.read_csv('matching_data_other.csv')
df_belum = pd.read_csv('matching_data_belum.csv')
df_karyawan = pd.read_csv('matching_data_karyawan.csv')
df_mahasiswa = pd.read_csv('matching_data_mahasiswa.csv')

# change to int
df.harga_program = df.harga_program.apply(lambda x : str(x))
df_other.harga_program = df_other.harga_program.apply(lambda x : str(x))
df_belum.harga_program = df_belum.harga_program.apply(lambda x : str(x))
df_karyawan.harga_program = df_karyawan.harga_program.apply(lambda x : str(x))
df_mahasiswa.harga_program = df_mahasiswa.harga_program.apply(lambda x : str(x))

df.info()

def split_input_output(data, target_column):
    """
    Function to separate input & output

    Parameters
    ----------
    data: pandas DataFrame
        Sample data.

    target_column: str
        Column name for output.

    Returns
    -------
    X: pandas DataFrame
        Input features.

    y: pandas Series
        Output variable.
    """
    # Find the output
    y = data[target_column]

    # Find the input
    X = data.drop(target_column, axis=1)

    return X, y

def _split_train_test(X, y, test_size=0.2, seed=123):
    """
    Function to separate data into training and testing sets.

    Parameters
    ----------
    X: pandas DataFrame
        Input features.

    y: pandas Series
        Output variable.

    test_size: float, optional
        Test data proportion.

    seed: int, optional
        Random state.

    Returns
    -------
    X_train: pandas DataFrame
        Training set input features.

    X_test: pandas DataFrame
        Testing set input features.

    y_train: pandas Series
        Training set output variable.

    y_test: pandas Series
        Testing set output variable.
    """
    X_train, X_test, y_train, y_test = train_test_split(X, y, stratify=y, test_size=test_size, random_state=seed)
    return X_train, X_test, y_train, y_test

def Ohe_encoder(data):
    """
    Function to perform one-hot encoding.

    Parameters
    ----------
    data: pandas DataFrame
        Categorical data to be encoded.

    Returns
    -------
    ohe: pandas DataFrame
        Encoded data using one-hot encoding.
    """
    ohe = pd.get_dummies(data)
    return ohe

class Scaling:
    """
    Class for scaling data.

    Attributes
    ----------
    None

    Methods
    -------
    standardizeData(data, scaler=None):
        Standardizes the input data.

    Normalizer(data):
        Normalizes the input data.
    """

    def __init__(self):
        pass

    def standardizeData(self, data, scaler=None):
        """
        Standardizes the input data.

        Parameters
        ----------
        data: pandas DataFrame
            Data to be standardized.

        scaler: StandardScaler, optional
            Scaler object. If None, a new scaler will be fitted.

        Returns
        -------
        data_scaled: pandas DataFrame
            Standardized data.

        scaler: StandardScaler
            Fitted scaler object.
        """
        if scaler is None:
            # Fit scaler
            scaler = StandardScaler()
            scaler.fit(data)

        # Transform data
        data_scaled = scaler.transform(data)
        data_scaled = pd.DataFrame(data_scaled, index=data.index, columns=data.columns)

        return data_scaled, scaler

    def Normalizer(self, data):
        """
        Normalizes the input data.

        Parameters
        ----------
        data: pandas DataFrame
            Data to be normalized.

        Returns
        -------
        normalized_data: pandas DataFrame
            Normalized data.

        normal: Normalizer
            Fitted normalizer object.
        """
        # Make scaler
        normal = Normalizer()

        # Normalize the data (fit)
        normalized_data = normal.fit_transform(data)
        normalized_data = pd.DataFrame(normalized_data, index=data.index, columns=data.columns)

        return normalized_data, normal

def logisitc_model(X_train, y_train):
    """
    Creates and fits a logistic regression model, and prints the recall score.

    Parameters
    ----------
    X_train: pandas DataFrame
        Training set input features.

    y_train: pandas Series
        Training set output variable.

    Returns
    -------
    None
    """
    # Create logistic model
    model = LogisticRegression(penalty=None, class_weight='balanced')

    # Fit the model on training data
    model.fit(X_train, y_train)

    # Make predictions on training data
    y_pred = model.predict(X_train)

    # Score metrics
    results = recall_score(y_train, y_pred)
    return print(f'recall_score, {results}')

def weight_summary(data, y_train):
    """
    Creates and fits a logistic regression model, and returns a summary of feature weights.

    Parameters
    ----------
    data: pandas DataFrame
        Input features.

    y_train: pandas Series
        Output variable.

    Returns
    -------
    summary: pandas DataFrame
        Summary of feature weights.
    """
    # Create logistic model
    model = LogisticRegression(penalty=None, class_weight='balanced')

    # Fit the model on training data
    model.fit(data, y_train)

    summary = pd.DataFrame({'features': data.columns.tolist() + ['constant'],
                            'weights': model.coef_[0].tolist() + model.intercept_.tolist()})
    summary = summary.sort_values(by='weights', ascending=False)

    return summary

"""#Result Weigth"""

def predict(data):
    """
    Predict function for a logistic regression model.

    Parameters
    ----------
    data: pandas DataFrame
        Input data.

    Returns
    -------
    result: pandas DataFrame
        Summary of feature weights from the logistic regression model.
    """
    # Split input and output
    X, y = split_input_output(data=data, target_column='choice')

    # Split data into training and testing sets
    X_train, X_test, y_train, y_test = _split_train_test(X, y, test_size=0.2, seed=123)

    # Perform one-hot encoding on training data
    X_train_encoded = Ohe_encoder(data=X_train)

    # Standardize the training data
    scaling = Scaling()
    X_train_standardized, scaler_standardized = scaling.standardizeData(X_train_encoded)

    # Calculate feature weights using logistic regression
    result = weight_summary(data=X_train_standardized, y_train=y_train)

    return result

# weigth
predict(data = df)

# weigth
predict(data = df_other)

# weigth
predict(data = df_belum)

# weigth
predict(data = df_karyawan)

# weight
predict(df_mahasiswa)

"""1. p(choice = 1 | feature)

$$
P(choice=1 | feature_i) =
\sigma(\cfrac{P(c=1)}{P(c=0)})
$$

$$
P(choice=1 | feature_i) =
\sigma(w_{1} feat_{1} + w_{2} feat_{2} + \cdots + w_{0})
$$

$$
odds = 0.3 \ \text{applide course} - 0.1 \ \text{basic course}
$$

Example:

we sell applied, then applied = 1, basic = 0

odds = 0.3 (1) - 0.1 (0)
odds = 0.3

odds_basic = 0.3(0) - 0.1(1)
odds = -0.1

The odds are the proportion of comparisons between yes and no.
- Odds 1 means the tendency not to choose anything.
- ods more than 1, including selecting

# Optimize Price
"""

def price_popular(data):
    """
    Function for find popular feature

    Parameter :
    -----------
    data :
      input data survey

    Return :
    --------
      return new dataframe with columns count and harga_program
    """
    # groping data
    df_other_grouped = data.groupby(['harga_program', 'choice']).size().\
                                    reset_index(name='count')

    # filtering choice that have 1
    condition_df_other = df_other_grouped[df_other_grouped['choice'] == 1]

    # create new dataframe
    condition_df_other = condition_df_other[['harga_program', 'count']]

    return condition_df_other

def optimize_price(data) :
  """
  Function for know optimze price with model linear regression

  * Formula :
    Q = Intercpet + Slope * P
      - P = Price
      - Q = Quantity

    *Find P
  - Revenue = P * (intercept + (Slope * P))
  - Revenue = interceptP + slopeP**2
  - Revenue = intercept + 2*Slope
  - 0 = intercept + slopeP
  - P = intercept + slope

  Parameters :
  ------------
  data : pd.Dataframe
   input data survey

  Returns :
  ---------
  revenue : float
    result in recommendation revenue that will be generated

  harga_optimal : float
    result in an optimal price that will be sold
  """
  # run function price_popular
  df_price = price_popular(data = data)

  # create new variable
  price = df_price['harga_program']
  quantity = df_price['count']

  # model
  model = LinearRegression()
  price = price.values.reshape(-1, 1)

  # fit model with price and quantity
  model.fit(price, quantity)

  # obtain slope and intercept
  slope = model.coef_[0]
  intercept = model.intercept_

  # find price optimum
  x = intercept + (2*slope)
  P = intercept + slope

  # find Quantity optimum
  Q = intercept + (slope * P)

  # obtain optimze revenue
  Revenue = P * Q

  # find the index corresponding to the maximum revenue
  index_optimal = np.argmax(Revenue)

  # obtain the corresponding optimal price
  harga_optimal = price[index_optimal]

  print(f"Price Optimal is {harga_optimal[0]}")
  print(f"Revenue Optimal is {Revenue}")

  return Revenue, harga_optimal

Revenue, harga_optimal = optimize_price(data = df)

# Simulasi Pertumbuhan Pendapatan dalam Tiga Bulan
def simulation(Revenue, harga_optimal, current_revenue_monthly,
               target_growth_rate, decreasing_rate, month_target) :

    # Assumtion target growth and revenue monthly (currently)
    current_monthly_revenue = current_revenue_monthly
    target_growth_rate = target_growth_rate

    # result from Conjoint Analysis
    optimal_price = harga_optimal
    expected_revenue = Revenue

    # Simulation growth revenue
    simulated_revenue_after_decline = current_monthly_revenue * (1 - decreasing_rate)

    # Income Projection for Three Months
    simulated_revenue = simulated_revenue_after_decline
    for _ in range(month_target):
        simulated_revenue *= (1 + target_growth_rate)

    # Output
    print(f"Revenue first monthly after decrasing: ${simulated_revenue_after_decline}")
    print(f"Expected revenue after growing in 3 months: ${simulated_revenue}")
    print(f"Price Optimze: ${optimal_price}")
    print(f"Revenue Optimize: ${expected_revenue}")

    #Evaluation target
    if simulated_revenue >= current_monthly_revenue * (1 + target_growth_rate):
        print("Congrats : Simulation achieves the target.")
    else:
        print("Simulation not achieves the target.")

simulation(Revenue = Revenue ,
           harga_optimal = harga_optimal,
           current_revenue_monthly = 100_000_000,
           target_growth_rate = 0.30,
           decreasing_rate = 0.15,
           month_target = 3)